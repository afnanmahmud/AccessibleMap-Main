{"ast":null,"code":"/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport DataTile, { asImageLike } from '../../DataTile.js';\nimport ImageTile from '../../ImageTile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport { ascending } from '../../array.js';\nimport { containsCoordinate, createEmpty, equals, getIntersection, getRotatedViewport, getTopLeft, intersects } from '../../extent.js';\nimport { fromUserExtent } from '../../proj.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport { toSize } from '../../size.js';\nimport LRUCache from '../../structs/LRUCache.js';\nimport { createOrUpdate as createTileCoord, getKeyZXY } from '../../tilecoord.js';\nimport { apply as applyTransform, compose as composeTransform } from '../../transform.js';\nimport { getUid } from '../../util.js';\nimport CanvasLayerRenderer from './Layer.js';\n\n/**\n * @param {string} sourceKey The source key.\n * @param {number} z The tile z level.\n * @param {number} x The tile x level.\n * @param {number} y The tile y level.\n * @return {string} The cache key.\n */\nfunction getCacheKey(sourceKey, z, x, y) {\n  return `${sourceKey},${getKeyZXY(z, x, y)}`;\n}\n\n/**\n * @typedef {Object<number, Set<import(\"../../Tile.js\").default>>} TileLookup\n */\n\n/**\n * Add a tile to the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was added to the lookup.\n */\nfunction addTileToLookup(tilesByZ, tile, z) {\n  if (!(z in tilesByZ)) {\n    tilesByZ[z] = new Set([tile]);\n    return true;\n  }\n  const set = tilesByZ[z];\n  const existing = set.has(tile);\n  if (!existing) {\n    set.add(tile);\n  }\n  return !existing;\n}\n\n/**\n * Remove a tile from the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was removed from the lookup.\n */\nfunction removeTileFromLookup(tilesByZ, tile, z) {\n  const set = tilesByZ[z];\n  if (set) {\n    return set.delete(tile);\n  }\n  return false;\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(extent, fromUserExtent(layerState.extent, frameState.viewState.projection));\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */\n  layerState.layer.getRenderSource();\n  if (!source.getWrapX()) {\n    const gridExtent = source.getTileGridForProjection(frameState.viewState.projection).getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\n/**\n * @typedef {Object} Options\n * @property {number} [cacheSize=512] The cache size.\n */\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer);\n    options = options || {};\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default|null}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.renderedSourceKey_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedSourceRevision_;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tempExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../Tile.js\").default>}\n     * @private\n     */\n    this.tileCache_ = new LRUCache(cacheSize);\n    this.maxStaleKeys = cacheSize * 0.5;\n  }\n\n  /**\n   * @return {LRUCache} Tile cache.\n   */\n  getTileCache() {\n    return this.tileCache_;\n  }\n\n  /**\n   * Get a tile from the cache or create one if needed.\n   *\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getOrCreateTile(z, x, y, frameState) {\n    const tileCache = this.tileCache_;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const cacheKey = getCacheKey(tileSource.getKey(), z, x, y);\n\n    /** @type {import(\"../../Tile.js\").default} */\n    let tile;\n    if (tileCache.containsKey(cacheKey)) {\n      tile = tileCache.get(cacheKey);\n    } else {\n      tile = tileSource.getTile(z, x, y, frameState.pixelRatio, frameState.viewState.projection);\n      if (!tile) {\n        return null;\n      }\n      tileCache.set(cacheKey, tile);\n    }\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getTile(z, x, y, frameState) {\n    const tile = this.getOrCreateTile(z, x, y, frameState);\n    if (!tile) {\n      return null;\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   * @override\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n    const layer = this.getLayer();\n    const coordinate = applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n    for (let z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = this.getTile(z, tileCoord[1], tileCoord[2], frameState);\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      /**\n       * @type {import('../../DataTile.js').ImageLike}\n       */\n      let image;\n      if (tile instanceof ImageTile || tile instanceof ReprojTile) {\n        image = tile.getImage();\n      } else if (tile instanceof DataTile) {\n        image = asImageLike(tile.getData());\n        if (!image) {\n          continue;\n        }\n      } else {\n        continue;\n      }\n      const col = Math.floor(tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0]));\n      const row = Math.floor(tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1]));\n      const gutter = Math.round(tilePixelRatio * source.getGutterForProjection(viewState.projection));\n      return this.getImageData(image, col + gutter, row + gutter);\n    }\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    if (!this.renderedProjection) {\n      this.renderedProjection = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.renderedProjection) {\n      this.tileCache_.clear();\n      this.renderedProjection = frameState.viewState.projection;\n    }\n    const source = this.getLayer().getSource();\n    if (!source) {\n      return false;\n    }\n    const sourceRevision = source.getRevision();\n    if (!this.renderedRevision_) {\n      this.renderedRevision_ = sourceRevision;\n    } else if (this.renderedRevision_ !== sourceRevision) {\n      this.renderedRevision_ = sourceRevision;\n      if (this.renderedSourceKey_ === source.getKey()) {\n        this.tileCache_.clear();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(initialZ - preload, tileGrid.getMinZoom(), tileGrid.getZForResolution(Math.min(tileLayer.getMaxResolution(), map ? map.getView().getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0)) : tileGrid.getResolution(0)), tileSource.zDirection));\n    const rotation = viewState.rotation;\n    const viewport = rotation ? getRotatedViewport(viewState.center, viewState.resolution, rotation, frameState.size) : undefined;\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, this.tempTileRange_);\n      const tileResolution = tileGrid.getResolution(z);\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {\n            continue;\n          }\n          const tile = this.getTile(z, x, y, frameState);\n          if (!tile) {\n            continue;\n          }\n          const added = addTileToLookup(tilesByZ, tile, z);\n          if (!added) {\n            continue;\n          }\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n              frameState.tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tileCoord), tileResolution]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findStaleTile_(tileCoord, tilesByZ) {\n    const tileCache = this.tileCache_;\n    const z = tileCoord[0];\n    const x = tileCoord[1];\n    const y = tileCoord[2];\n    const staleKeys = this.getStaleKeys();\n    for (let i = 0; i < staleKeys.length; ++i) {\n      const cacheKey = getCacheKey(staleKeys[i], z, x, y);\n      if (tileCache.containsKey(cacheKey)) {\n        const tile = tileCache.peek(cacheKey);\n        if (tile.getState() === TileState.LOADED) {\n          tile.endTransition(getUid(this));\n          addTileToLookup(tilesByZ, tile, z);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(tileCoord, altZ, this.tempTileRange_);\n    if (!tileRange) {\n      return false;\n    }\n    let covered = true;\n    const tileCache = this.tileCache_;\n    const source = this.getLayer().getRenderSource();\n    const sourceKey = source.getKey();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(sourceKey, altZ, x, y);\n        let loaded = false;\n        if (tileCache.containsKey(cacheKey)) {\n          const tile = tileCache.peek(cacheKey);\n          if (tile.getState() === TileState.LOADED) {\n            addTileToLookup(tilesByZ, tile, altZ);\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  /**\n   * Render the layer.\n   *\n   * The frame rendering logic has three parts:\n   *\n   *  1. Enqueue tiles\n   *  2. Find alt tiles for those that are not yet loaded\n   *  3. Render loaded tiles\n   *\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState, target) {\n    let allTilesIdle = true;\n    this.renderComplete = true;\n\n    /**\n     * TODO:\n     *  maybe skip transition when not fully opaque\n     *  decide if this.renderComplete is useful\n     */\n\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const pixelRatio = frameState.pixelRatio;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n    const sourceKey = tileSource.getKey();\n    if (!this.renderedSourceKey_) {\n      this.renderedSourceKey_ = sourceKey;\n    } else if (this.renderedSourceKey_ !== sourceKey) {\n      this.prependStaleKey(this.renderedSourceKey_);\n      this.renderedSourceKey_ = sourceKey;\n    }\n    let frameExtent = frameState.extent;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n    const layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      frameExtent = getIntersection(frameExtent, fromUserExtent(layerState.extent, projection));\n    }\n    const dx = tileResolution * width / 2 / tilePixelRatio;\n    const dy = tileResolution * height / 2 / tilePixelRatio;\n    const canvasExtent = [viewCenter[0] - dx, viewCenter[1] - dy, viewCenter[0] + dx, viewCenter[1] + dy];\n\n    /**\n     * @type {TileLookup}\n     */\n    const tilesByZ = {};\n    this.renderedTiles.length = 0;\n\n    /**\n     * Part 1: Enqueue tiles\n     */\n\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(viewState.nextResolution, tileSource.zDirection);\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(frameState, nextExtent, targetZ, tilesByZ, preload);\n    }\n    const renderExtent = getRenderExtent(frameState, frameExtent);\n    this.enqueueTiles(frameState, renderExtent, z, tilesByZ, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(frameState, renderExtent, z - 1, tilesByZ, preload - 1);\n      }, 0);\n    }\n    if (!(z in tilesByZ)) {\n      return this.container;\n    }\n\n    /**\n     * Part 2: Find alt tiles for those that are not yet loaded\n     */\n\n    const uid = getUid(this);\n    const time = frameState.time;\n\n    // look for cached tiles to use if a target tile is not ready\n    for (const tile of tilesByZ[z]) {\n      const tileState = tile.getState();\n      if (tileState === TileState.EMPTY) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n      if (tileState === TileState.LOADED) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n      }\n      if (tileState !== TileState.IDLE) {\n        allTilesIdle = false;\n      }\n      if (tileState !== TileState.ERROR) {\n        this.renderComplete = false;\n      }\n      const hasStaleTile = this.findStaleTile_(tileCoord, tilesByZ);\n      if (hasStaleTile) {\n        // use the stale tile before the new tile's transition has completed\n        removeTileFromLookup(tilesByZ, tile, z);\n        frameState.animate = true;\n        continue;\n      }\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(tileGrid, tileCoord, z + 1, tilesByZ);\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(tileGrid, tileCoord, parentZ, tilesByZ);\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    /**\n     * Part 3: Render loaded tiles\n     */\n\n    const canvasScale = tileResolution / viewResolution * pixelRatio / tilePixelRatio;\n    const context = this.getRenderContext(frameState);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);\n    if (layerState.extent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n    this.preRender(context, frameState);\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(tilesByZ).map(Number);\n    zs.sort(ascending);\n    let currentClip;\n    const clips = [];\n    const clipZs = [];\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(getTopLeft(canvasExtent), currentZ);\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution, tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution]);\n      const tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);\n      for (const tile of tilesByZ[currentZ]) {\n        if (tile.getState() !== TileState.LOADED) {\n          continue;\n        }\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = zs.length === 1;\n        let contextSaved = false;\n\n        // Clip mask for regions in this tile that already filled by a higher z tile\n        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n        for (let i = 0, ii = clips.length; i < ii; ++i) {\n          if (!transition && currentZ < clipZs[i]) {\n            const clip = clips[i];\n            if (intersects([x, y, x + w, y + h], [clip[0], clip[3], clip[4], clip[7]])) {\n              if (!contextSaved) {\n                context.save();\n                contextSaved = true;\n              }\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n        this.drawTile(tile, frameState, x, y, w, h, tileGutter, transition);\n        if (contextSaved) {\n          context.restore();\n        }\n        this.renderedTiles.unshift(tile);\n\n        // TODO: decide if this is necessary\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n    this.renderedResolution = tileResolution;\n    this.extentChanged = !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.postRender(this.context, frameState);\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n    if (this.renderComplete) {\n      /**\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = (map, frameState) => {\n        const tileSourceKey = getUid(tileSource);\n        const wantedTiles = frameState.wantedTiles[tileSourceKey];\n        const tilesCount = wantedTiles ? Object.keys(wantedTiles).length : 0;\n        this.updateCacheSize(tilesCount);\n        this.tileCache_.expireCache();\n      };\n      frameState.postRenderFunctions.push(postRenderFunction);\n    }\n    if (!this.renderComplete && !allTilesIdle) {\n      frameState.animate = true;\n    }\n    return this.container;\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   */\n  updateCacheSize(tileCount) {\n    this.tileCache_.highWaterMark = Math.max(this.tileCache_.highWaterMark, tileCount * 2);\n  }\n\n  /**\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @protected\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    let image;\n    if (tile instanceof DataTile) {\n      image = asImageLike(tile.getData());\n      if (!image) {\n        throw new Error('Rendering array data is not yet supported');\n      }\n    } else {\n      image = this.getTileImage(/** @type {import(\"../../ImageTile.js\").default} */tile);\n    }\n    if (!image) {\n      return;\n    }\n    const context = this.getRenderContext(frameState);\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha = layerState.opacity * (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== context.globalAlpha;\n    if (alphaChanged) {\n      context.save();\n      context.globalAlpha = alpha;\n    }\n    context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n    if (alphaChanged) {\n      context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n}\nexport default CanvasTileLayerRenderer;","map":{"version":3,"names":["DataTile","asImageLike","ImageTile","TileRange","TileState","ascending","containsCoordinate","createEmpty","equals","getIntersection","getRotatedViewport","getTopLeft","intersects","fromUserExtent","ReprojTile","toSize","LRUCache","createOrUpdate","createTileCoord","getKeyZXY","apply","applyTransform","compose","composeTransform","getUid","CanvasLayerRenderer","getCacheKey","sourceKey","z","x","y","addTileToLookup","tilesByZ","tile","Set","set","existing","has","add","removeTileFromLookup","delete","getRenderExtent","frameState","extent","layerState","layerStatesArray","layerIndex","viewState","projection","source","layer","getRenderSource","getWrapX","gridExtent","getTileGridForProjection","getExtent","CanvasTileLayerRenderer","constructor","tileLayer","options","extentChanged","renderComplete","renderedExtent_","renderedPixelRatio","renderedProjection","renderedRevision_","renderedTiles","renderedSourceKey_","renderedSourceRevision_","tempExtent","tempTileRange_","tempTileCoord_","cacheSize","undefined","tileCache_","maxStaleKeys","getTileCache","getOrCreateTile","tileCache","getLayer","tileSource","getSource","cacheKey","getKey","containsKey","get","getTile","pixelRatio","getData","pixel","coordinate","pixelToCoordinateTransform","slice","layerExtent","tileGrid","tilePixelRatio","getTilePixelRatio","getZForResolution","resolution","getMinZoom","tileCoord","getTileCoordForCoordAndZ","getState","LOADED","tileOrigin","getOrigin","tileSize","getTileSize","tileResolution","getResolution","image","getImage","col","Math","floor","row","gutter","round","getGutterForProjection","getImageData","prepareFrame","clear","sourceRevision","getRevision","enqueueTiles","initialZ","preload","tileSourceKey","wantedTiles","map","getMapInternal","minZ","max","min","getMaxResolution","getView","getResolutionForZoom","zDirection","rotation","viewport","center","size","tileRange","getTileRangeForExtentAndZ","minX","maxX","minY","maxY","tileCoordIntersectsViewport","added","tileQueueKey","IDLE","tileQueue","isKeyQueued","enqueue","getTileCoordCenter","findStaleTile_","staleKeys","getStaleKeys","i","length","peek","endTransition","findAltTiles_","altZ","getTileRangeForTileCoordAndZ","covered","loaded","renderFrame","target","allTilesIdle","viewResolution","viewCenter","prependStaleKey","frameExtent","prepareContainer","width","context","canvas","height","dx","dy","canvasExtent","getPreload","nextExtent","targetZ","nextResolution","renderExtent","setTimeout","container","uid","time","tileState","EMPTY","alpha","getAlpha","ERROR","hasStaleTile","animate","coveredByChildren","minZoom","parentZ","coveredByParent","canvasScale","getRenderContext","tempTransform","clipUnrotated","getInterpolate","imageSmoothingEnabled","preRender","zs","Object","keys","Number","sort","currentClip","clips","clipZs","currentZ","currentTilePixelSize","getTilePixelSize","currentResolution","currentScale","originTileCoord","originTileExtent","getTileCoordExtent","origin","tileGutter","xIndex","nextX","yIndex","nextY","w","h","transition","contextSaved","ii","clip","save","beginPath","moveTo","lineTo","push","drawTile","restore","unshift","updateUsedTiles","usedTiles","renderedResolution","postRender","postRenderFunction","tilesCount","updateCacheSize","expireCache","postRenderFunctions","tileCount","highWaterMark","Error","getTileImage","opacity","alphaChanged","globalAlpha","drawImage"],"sources":["/Users/kenn/Documents/GitHub/AccessibleMapBackup/node_modules/ol/renderer/canvas/TileLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport DataTile, {asImageLike} from '../../DataTile.js';\nimport ImageTile from '../../ImageTile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {ascending} from '../../array.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getIntersection,\n  getRotatedViewport,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport {toSize} from '../../size.js';\nimport LRUCache from '../../structs/LRUCache.js';\nimport {createOrUpdate as createTileCoord, getKeyZXY} from '../../tilecoord.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n} from '../../transform.js';\nimport {getUid} from '../../util.js';\nimport CanvasLayerRenderer from './Layer.js';\n\n/**\n * @param {string} sourceKey The source key.\n * @param {number} z The tile z level.\n * @param {number} x The tile x level.\n * @param {number} y The tile y level.\n * @return {string} The cache key.\n */\nfunction getCacheKey(sourceKey, z, x, y) {\n  return `${sourceKey},${getKeyZXY(z, x, y)}`;\n}\n\n/**\n * @typedef {Object<number, Set<import(\"../../Tile.js\").default>>} TileLookup\n */\n\n/**\n * Add a tile to the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was added to the lookup.\n */\nfunction addTileToLookup(tilesByZ, tile, z) {\n  if (!(z in tilesByZ)) {\n    tilesByZ[z] = new Set([tile]);\n    return true;\n  }\n  const set = tilesByZ[z];\n  const existing = set.has(tile);\n  if (!existing) {\n    set.add(tile);\n  }\n  return !existing;\n}\n\n/**\n * Remove a tile from the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was removed from the lookup.\n */\nfunction removeTileFromLookup(tilesByZ, tile, z) {\n  const set = tilesByZ[z];\n  if (set) {\n    return set.delete(tile);\n  }\n  return false;\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(\n      extent,\n      fromUserExtent(layerState.extent, frameState.viewState.projection),\n    );\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */ (\n    layerState.layer.getRenderSource()\n  );\n  if (!source.getWrapX()) {\n    const gridExtent = source\n      .getTileGridForProjection(frameState.viewState.projection)\n      .getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\n/**\n * @typedef {Object} Options\n * @property {number} [cacheSize=512] The cache size.\n */\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer);\n\n    options = options || {};\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default|null}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.renderedSourceKey_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedSourceRevision_;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tempExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../Tile.js\").default>}\n     * @private\n     */\n    this.tileCache_ = new LRUCache(cacheSize);\n\n    this.maxStaleKeys = cacheSize * 0.5;\n  }\n\n  /**\n   * @return {LRUCache} Tile cache.\n   */\n  getTileCache() {\n    return this.tileCache_;\n  }\n\n  /**\n   * Get a tile from the cache or create one if needed.\n   *\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getOrCreateTile(z, x, y, frameState) {\n    const tileCache = this.tileCache_;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const cacheKey = getCacheKey(tileSource.getKey(), z, x, y);\n\n    /** @type {import(\"../../Tile.js\").default} */\n    let tile;\n\n    if (tileCache.containsKey(cacheKey)) {\n      tile = tileCache.get(cacheKey);\n    } else {\n      tile = tileSource.getTile(\n        z,\n        x,\n        y,\n        frameState.pixelRatio,\n        frameState.viewState.projection,\n      );\n      if (!tile) {\n        return null;\n      }\n      tileCache.set(cacheKey, tile);\n    }\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getTile(z, x, y, frameState) {\n    const tile = this.getOrCreateTile(z, x, y, frameState);\n    if (!tile) {\n      return null;\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   * @override\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice(),\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = this.getTile(z, tileCoord[1], tileCoord[2], frameState);\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      /**\n       * @type {import('../../DataTile.js').ImageLike}\n       */\n      let image;\n      if (tile instanceof ImageTile || tile instanceof ReprojTile) {\n        image = tile.getImage();\n      } else if (tile instanceof DataTile) {\n        image = asImageLike(tile.getData());\n        if (!image) {\n          continue;\n        }\n      } else {\n        continue;\n      }\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0]),\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1]),\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection),\n      );\n\n      return this.getImageData(image, col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    if (!this.renderedProjection) {\n      this.renderedProjection = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.renderedProjection) {\n      this.tileCache_.clear();\n      this.renderedProjection = frameState.viewState.projection;\n    }\n\n    const source = this.getLayer().getSource();\n    if (!source) {\n      return false;\n    }\n    const sourceRevision = source.getRevision();\n    if (!this.renderedRevision_) {\n      this.renderedRevision_ = sourceRevision;\n    } else if (this.renderedRevision_ !== sourceRevision) {\n      this.renderedRevision_ = sourceRevision;\n      if (this.renderedSourceKey_ === source.getKey()) {\n        this.tileCache_.clear();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(\n      initialZ - preload,\n      tileGrid.getMinZoom(),\n      tileGrid.getZForResolution(\n        Math.min(\n          tileLayer.getMaxResolution(),\n          map\n            ? map\n                .getView()\n                .getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0))\n            : tileGrid.getResolution(0),\n        ),\n        tileSource.zDirection,\n      ),\n    );\n    const rotation = viewState.rotation;\n    const viewport = rotation\n      ? getRotatedViewport(\n          viewState.center,\n          viewState.resolution,\n          rotation,\n          frameState.size,\n        )\n      : undefined;\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        extent,\n        z,\n        this.tempTileRange_,\n      );\n\n      const tileResolution = tileGrid.getResolution(z);\n\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (\n            rotation &&\n            !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n          ) {\n            continue;\n          }\n          const tile = this.getTile(z, x, y, frameState);\n          if (!tile) {\n            continue;\n          }\n          const added = addTileToLookup(tilesByZ, tile, z);\n          if (!added) {\n            continue;\n          }\n\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n              frameState.tileQueue.enqueue([\n                tile,\n                tileSourceKey,\n                tileGrid.getTileCoordCenter(tileCoord),\n                tileResolution,\n              ]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findStaleTile_(tileCoord, tilesByZ) {\n    const tileCache = this.tileCache_;\n    const z = tileCoord[0];\n    const x = tileCoord[1];\n    const y = tileCoord[2];\n    const staleKeys = this.getStaleKeys();\n    for (let i = 0; i < staleKeys.length; ++i) {\n      const cacheKey = getCacheKey(staleKeys[i], z, x, y);\n      if (tileCache.containsKey(cacheKey)) {\n        const tile = tileCache.peek(cacheKey);\n        if (tile.getState() === TileState.LOADED) {\n          tile.endTransition(getUid(this));\n          addTileToLookup(tilesByZ, tile, z);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(\n      tileCoord,\n      altZ,\n      this.tempTileRange_,\n    );\n\n    if (!tileRange) {\n      return false;\n    }\n\n    let covered = true;\n    const tileCache = this.tileCache_;\n    const source = this.getLayer().getRenderSource();\n    const sourceKey = source.getKey();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(sourceKey, altZ, x, y);\n        let loaded = false;\n        if (tileCache.containsKey(cacheKey)) {\n          const tile = tileCache.peek(cacheKey);\n          if (tile.getState() === TileState.LOADED) {\n            addTileToLookup(tilesByZ, tile, altZ);\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  /**\n   * Render the layer.\n   *\n   * The frame rendering logic has three parts:\n   *\n   *  1. Enqueue tiles\n   *  2. Find alt tiles for those that are not yet loaded\n   *  3. Render loaded tiles\n   *\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState, target) {\n    let allTilesIdle = true;\n    this.renderComplete = true;\n\n    /**\n     * TODO:\n     *  maybe skip transition when not fully opaque\n     *  decide if this.renderComplete is useful\n     */\n\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    const sourceKey = tileSource.getKey();\n    if (!this.renderedSourceKey_) {\n      this.renderedSourceKey_ = sourceKey;\n    } else if (this.renderedSourceKey_ !== sourceKey) {\n      this.prependStaleKey(this.renderedSourceKey_);\n      this.renderedSourceKey_ = sourceKey;\n    }\n\n    let frameExtent = frameState.extent;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      frameExtent = getIntersection(\n        frameExtent,\n        fromUserExtent(layerState.extent, projection),\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    /**\n     * @type {TileLookup}\n     */\n    const tilesByZ = {};\n\n    this.renderedTiles.length = 0;\n\n    /**\n     * Part 1: Enqueue tiles\n     */\n\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(\n        viewState.nextResolution,\n        tileSource.zDirection,\n      );\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(frameState, nextExtent, targetZ, tilesByZ, preload);\n    }\n\n    const renderExtent = getRenderExtent(frameState, frameExtent);\n    this.enqueueTiles(frameState, renderExtent, z, tilesByZ, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(\n          frameState,\n          renderExtent,\n          z - 1,\n          tilesByZ,\n          preload - 1,\n        );\n      }, 0);\n    }\n\n    if (!(z in tilesByZ)) {\n      return this.container;\n    }\n\n    /**\n     * Part 2: Find alt tiles for those that are not yet loaded\n     */\n\n    const uid = getUid(this);\n    const time = frameState.time;\n\n    // look for cached tiles to use if a target tile is not ready\n    for (const tile of tilesByZ[z]) {\n      const tileState = tile.getState();\n      if (tileState === TileState.EMPTY) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n\n      if (tileState === TileState.LOADED) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n      }\n      if (tileState !== TileState.IDLE) {\n        allTilesIdle = false;\n      }\n      if (tileState !== TileState.ERROR) {\n        this.renderComplete = false;\n      }\n\n      const hasStaleTile = this.findStaleTile_(tileCoord, tilesByZ);\n      if (hasStaleTile) {\n        // use the stale tile before the new tile's transition has completed\n        removeTileFromLookup(tilesByZ, tile, z);\n        frameState.animate = true;\n        continue;\n      }\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(\n        tileGrid,\n        tileCoord,\n        z + 1,\n        tilesByZ,\n      );\n\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(\n          tileGrid,\n          tileCoord,\n          parentZ,\n          tilesByZ,\n        );\n\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    /**\n     * Part 3: Render loaded tiles\n     */\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    const context = this.getRenderContext(frameState);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2,\n    );\n\n    if (layerState.extent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(tilesByZ).map(Number);\n    zs.sort(ascending);\n\n    let currentClip;\n    const clips = [];\n    const clipZs = [];\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection,\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ,\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      for (const tile of tilesByZ[currentZ]) {\n        if (tile.getState() !== TileState.LOADED) {\n          continue;\n        }\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = zs.length === 1;\n\n        let contextSaved = false;\n\n        // Clip mask for regions in this tile that already filled by a higher z tile\n        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n        for (let i = 0, ii = clips.length; i < ii; ++i) {\n          if (!transition && currentZ < clipZs[i]) {\n            const clip = clips[i];\n            if (\n              intersects(\n                [x, y, x + w, y + h],\n                [clip[0], clip[3], clip[4], clip[7]],\n              )\n            ) {\n              if (!contextSaved) {\n                context.save();\n                contextSaved = true;\n              }\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n\n        this.drawTile(tile, frameState, x, y, w, h, tileGutter, transition);\n        if (contextSaved) {\n          context.restore();\n        }\n        this.renderedTiles.unshift(tile);\n\n        // TODO: decide if this is necessary\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n\n    this.postRender(this.context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (this.renderComplete) {\n      /**\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = (map, frameState) => {\n        const tileSourceKey = getUid(tileSource);\n        const wantedTiles = frameState.wantedTiles[tileSourceKey];\n        const tilesCount = wantedTiles ? Object.keys(wantedTiles).length : 0;\n        this.updateCacheSize(tilesCount);\n        this.tileCache_.expireCache();\n      };\n\n      frameState.postRenderFunctions.push(postRenderFunction);\n    }\n    if (!this.renderComplete && !allTilesIdle) {\n      frameState.animate = true;\n    }\n\n    return this.container;\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   */\n  updateCacheSize(tileCount) {\n    this.tileCache_.highWaterMark = Math.max(\n      this.tileCache_.highWaterMark,\n      tileCount * 2,\n    );\n  }\n\n  /**\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @protected\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    let image;\n    if (tile instanceof DataTile) {\n      image = asImageLike(tile.getData());\n      if (!image) {\n        throw new Error('Rendering array data is not yet supported');\n      }\n    } else {\n      image = this.getTileImage(\n        /** @type {import(\"../../ImageTile.js\").default} */ (tile),\n      );\n    }\n    if (!image) {\n      return;\n    }\n    const context = this.getRenderContext(frameState);\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== context.globalAlpha;\n    if (alphaChanged) {\n      context.save();\n      context.globalAlpha = alpha;\n    }\n    context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h,\n    );\n\n    if (alphaChanged) {\n      context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}